// linux命令 linux系统
// V0.9

Q:相对路径
A:（1）绝对路径由 / 开始，如/usr/test/   
Q:相对路径
A:有如下几种：(1). ：表示此层目录；（2）.. ：表示上层目录；（3）- ：表示上一个工作目录；（4）~ ：表示当前用户所在的 home 目录；~account ： 表示account用户的 home 目录

Q:查看当前目录下的文件和目录
A:ls。 -a：全部文件    -l：显示详细信息
Q:复制文件
A:cp。-a：-pdr，即复制文件夹、复制文件属性、复制链接文件（而非文件对象）；  -f：强制   -v：
Q:删除目录和文件
A:rm。 -f：强制删除；   -r：删除目录
Q:移动目录和文件，或者重命名
A:mv。  -f：强制；  -i：如果目标文件已经存在，则询问是否覆盖
Q:切换目录
A:cd
Q:显示当前目录
A:pwd
Q:建立新目录
A:mkdir.  -p：目录递归建立
Q:删除空目录
A:rmdir
Q:建立空文件
A:touch+文件名.
Q:测试文件（文件夹）相关属性
A:test.  -e：测试文件是否存在;  -f：测试指定名称是否为文件;  -d：测试指定名称是否为文件夹;  -n：判断字符串是否非空，非空返回ture
Q:挂载emmc分区（要root权限）
A:mkdir /sdcard/fat;   mount -t vfat /dev/block/mmcblk0p3 /sdcard/fat; 搞清楚一件事，linux的 mountpoint 真的是任意一个目录就可以。

Q:log打印
A:echo. 打印变量：echo $PATH
Q:变量及其赋值
A:字符串表示一个变量，赋值用=；使用时用前缀$表示一个变量。如：name="CB call"   year=9001   Path=$PATH:\home\dmtsail\bin

Q:切换为超级用户
A:su
Q:切换为指定用户
A:su 用户名
Q:使用超级用户权限运行这条命令
A:sudo。注意，其效力只限于当前命令。

Q:设置文件（目录）的访问权限
A:chmod。 -r：支持子目录   rg：chmod 777 文件名 (一个数字表示一个权限，即owner/group/others，7表示r+w+x，即全开。)

Q:清屏
A:clear

Q:用变量保存命令的输出
A:使用``（注意，非引号）  eg：echo 'date'

Q:查看命令的使用说明
A:man+命令。在显示界面下，空格  翻页；/***  查找***关键字；n 查找下一个；N 查找上一个；q 退出

Q:任务管理器
A:top

Q:获取/修改系统属性
A:adb中，getprop / setprop。

Q:显示谁在线
A:who
Q:查看当前网络联机状态
A:netstat -a
Q:查看后台执行的程序
A:ps -aux
Q:获取本机ip
A:ifconfig

Q:显示硬盘使用情况
A:df  -a：显示特殊分区；  -h：以GB、MB、KB来显示size；  -T：显示分区的文件系统类型；  -i：显示inode数量
Q:打印硬盘分区结构（如主引导区、分区表等）
A:dumpe2fs

Q:寻找并批量删除文件
A:find ./ -name .git | xargs rm -rvf

Q:寻找并改变文件编码
A:find -type f -exec sh -c 'iconv -f utf8 -t GBK -c $1>$1.tmp; mv $1.temp ../gbk_txt/$1' -{} /,

Q:查看分区信息
A:mount
Q:按fat32 mount
A:mount -t vfat /dev/block/mmcblk0p1 /sdcard
Q:remount，+rw属性
A:mount -t ext3 -o rw,remount /dev/block/mmcblk0p12 /system 
Q:umount
A:umount /sdcard
Q:扫描 fat 文件系统1
A:/system/bin/fsck_msdos -p -f /mnt/sdcard
Q:扫描 fat 文件系统2
A:fsck -t msdos -a /dev/block/mmcblk0p14
Q:格式化为fat32
A:/system/bin/newfs_msdos -F 32 -O android -c 8 -s 1024 /dev/block/mmcblk0p14
Q:格式化为 ext3
A:mke2fs -j -L "logical" /dev/block/mmcblk0p6
Q:扫描ext3 文件系统
A:/system/bin/e2fsck -p /dev/block/mmcblk0p6
Q:打印目录及子目录中的所有有后缀的文件名
A:find ./ -type f |egrep  "*.[a-z]*" > readme.txt
Q:解压缩
A:如果是bzip2 格式的(.bz2), 则使用 tar xvjf 文件名； 如果是zip格式(.gz), 则使用: tar xvzf 文件名
Q:快速备份或复制文件
A:cp filename{,.bak}
Q:traceroute + ping
A:mtr google.com
Q:更改到上一次访问的目录
A:cd -
Q:linux 脚本无法运行的可能原因
A:检查一下命令的拼写和大小写；是否目录错误；使用ls 查看当前目录；是否没有运行权限；使用 chmod命令修改；脚本文件如果是在 windows侧编辑的，那么就需要看一下换行符是否为0d0a，如果是，要改成linux的0a格式。
Q:格式化u盘
A:mkfs.vfat -I /dev/sde（先用mount查看u盘挂在那个点上）
Q:shell脚本之使用变量
A:定义变量: export my_VERSION=7x30_B001；    使用变量: ${my_VERSION}
Q:修改文件或文件夹的权限
A:chmod。eg:chmod 666 /dev/pcui。其中：6表示权限，r=4,w=2,x=1; 三个值对应：owner、owner主、other组三类用户。
Q:代码中修改文件的权限
A:system/core/include/private/android_filesystem_config.h，有 android_dirs[], android_files[]。

// 进程相关
Q:linux进程的堆栈
A:linux每个用户进程都有自己的堆栈，而且有两个，一个为系统堆栈，除1K的进程控制块外，还有7K的空间供内核进程调度时用于保存进程上下文。
Q:输出当前运行进程。可以获取进程号
A: ps：ps -x: 显示进程的运行时间；
Q:杀掉进程
A: kill+进程号。注意，系统进程杀掉后会马上重启。

// 内存管理
Q:linux内存管理api（1）
A:set_page_address() 和 page_address()，只针对高端内存。
Q:linux内存管理api（2）
A:ioremap() // 内存分配，地址是虚地址   phys_to_page() / virb_to_page() // 虚地址和实地址的互转
Q:查每个进程的内存使用
A:dumpsys meminfo + 进程名。对单个进程的内存有很细节的说明，包括object和sql。
Q:同时看所有进程的内存使用
A:procrank
Q:给出系统内存的大致使用情况
A:cat /proc/meminfo，注意数据的含义要辨别。
Q:给出各进程的vsize和rss
A:ps-x

// Linux 内核设计和实现
Q:Unix的强大之处（1）
A:简洁. unix 仅提供几百个系统调用. 而其它系统往往提供数千个系统调用，windows7 好几万。
Q:Unix的强大之处（2）
A:抽象。在系统中, 所有的东西都被看做文件. 对数据和设备的操作都可以抽象为 open/read/write/ioctl/close。
Q:Unix的强大之处（3）
A:内核使用c语言, 具有惊人的移植能力。
Q:Unix的强大之处（4）
A:进程创建迅速, 有一个非常独特的fork() 系统调用。
Q:Unix的强大之处（5）
A:简洁稳定的系统间通信原语.
Q:Linux诞生
A:1991年, Linux诞生。
Q:GNOME
A:图形用户桌面环境
Q:Linux 是单内核系统
A:Linux 内核运行在单独的内核地址空间, 直接调用函数, 无需消息传递。内核为一个不可分割的静态可执行块, 在一个独立的地址空间中运行, 需要硬件提供页机制以管理内存。
Q:单内核
A:整个系统为一个单独的进程来实现, 所有内核服务都在同一个地址空间内运行. 内核可以直接调用函数. unix , Linux 都属于单内核.
Q:微内核
A:内核功能划分为多个独立进程, 分别有自己的地址空间. 所以不能直接调用函数, 而是通过IPC消息来完成内核通讯. 优势在于安全, 一个进程的死掉一般不影响另一个. 缺点是IPC开销较之函数调用大很多, 所以性能不佳. WinNT 和 mac osx 都属于微内核.
Q:Linux的取舍
A:Linux 提供了抢占式内核, 支持内核线程, 以及动态装载内核模块的功能, 汲取了微内核的精华.
Q:Linux 方案设计的务实态度
A:任何改变都要针对现实中确实存在的问题, 经过完善的设计并有正确简洁的实现.
Q:内核没有libc库和其它库
A:但是大部分库函数已得到实现, 没有实现的最著名的是 printf(), 请用 printk() 代替. printk 可以设置优先级. 如:printk(KERN_ERR "This is a error!");
Q:内核开发的特点
A:（1）没有内存保护机制；（2）不要在内核中使用浮点数； （3）内核栈很小。
Q:进程管理
A:进程是操作系统最基本的抽象之一。进程即处在执行期的程序, 除程序代码外, 还有文件句柄, 信号, 内核内部数据, 处理器状态, 地址空间, 以及一个或多个线程 .
Q:线程
A:即进程中活动的对象. 内核调度的对象是线程, 而不是进程。Linux中, 每个线程都有自己的task_struct, 在内核眼里, 它就是进程, 不过是和其它进程共享地址空间而已.
Q:线程概率和windows的区别
A:这点和windows等操作系统完全不同. 在后者上, 线程被称为轻量级进程, 进程和线程分别有一套机制来管理. 而在Linux上, 由于进程就足够轻了. 所以没有必要分得太轻.
Q:进程提供两种虚拟机制
A:虚拟处理器和虚拟内存。同一进程的线程间, 共享虚拟内存, 但是虚拟处理器还是各自的。
Q:fork调用（1）
A:linux 中经常通过复制一个现有进程来创建新的进程. 调用 fork 的进程被称为父进程, 新产生的进程被称为子进程。
Q:fork调用（2）
A:在该调用结束时, 在返回点这个相同位置上, 父进程恢复执行, 子进程开始执行。fork系统调用从内核中返回两次, 一次回到父进程, 一次回到新诞生的子进程。
Q:fork返回值
A:fork通过返回值来判断现在跑在哪一个进程里。返回值为0表示当前进程为新产生的子进程，不为零（实际为pid）的即为父进程。
Q:fork之后这两个进程的关系
A:这这两个进程共享代码空间，即使用同一套代码，数据空间则相互独立。子进程的数据空间是父进程的完整copy（但不是马上copy，而是用时copy）。
Q:子进程如何加载自己的代码？
A:调用child()加载。
Q:task list和进程描述符
A:在 sched.h 中定义。每个进程都用进程描述符来描述, 所有的进程描述符放在一个叫 task list 的双向链表中。
Q:进程序号：PID
A:默认情况下，最大值为32768，这个值可以改。PPID：父进程序号，所有进程都是PID为1的 init进程的后代。
Q:进程状态：state
A:task_running、task_interruptible、task_uninterruptible、task_zombile、task_stopped。
Q:task_running
A:进程可执行(即就绪态). 它或者正在执行, 或者在运行队列中等待执行。进程在用户空间中执行的唯一可能的状态.
正在执行的进程, 可以被优先级更高的进程抢占, 此时被抢占的进程处在运行队列中等待执行.
Q:task_interruptible
A:进程在睡眠, 或者说被阻塞. 进程为了等待特定事件, 在等待队列中睡眠. 一旦等待的事件发生, 进程被唤醒并重新置入运行队列. 也可以被信号提前唤醒.
Q:task_uninterruptible
A:除了不会因为接受到信号而被唤醒外, 这个状态和上一个一样. 在进程执行重要操作时, 比如持有信号量, 为了避免被信号打断当前流程, 而是用此状态. 较少使用.
Q:task_zombile
A:僵死. 进程已经结束, 但是父进程还没有调用 wait4() 系统调用. 为了父进程能够知道其状态, 子进程的进程描述符仍被保留。
Q:task_stopped
A:停止，进程收到stop信号时退出。
Q:陷入
A:一般程序在用户空间执行. 而当它调用了一个系统调用, 或者触发了一个异常, 它就陷入了内核空间。
Q:进程创建（1）
A:linux 采用进程复制的方式快速创建进程. 因为在创建进程过程中仅需要分配新的PID 即可完成. 
Q:进程创建（2）
A:创建后的子进程和父进程共享同一个地址空间的拷贝. 只有在需要写入才会把父进程的相应页写入子进程的地址空间.  这叫写时拷贝技术.
Q:创建进程（3）
A:如果创建子进程后马上调用 exec() 来 load 自己的代码映像(一般情况是如此) , 则此拷贝根本不会发生. 因为此种情况下父进程和子进程的地址空间完全不相干.
Q:创建进程（4）
A:linux 上, 创建进程和创建线程基本一样. 不同点在于, 创建线程时, 需要指明共享资源.
Q:内核线程（1）
A:内核经常需要在后台执行一些操作，通过内核线程完成. 内核线程没有独立的地址空间, 它使用统一的内核空间. 其它和普通进程一样。
Q:内核线程（2）
A:一般内核线程会一直执行. 在需要的时候, 它会被唤醒和执行, 然后再次休眠.
Q:进程退出时要清理如下资源：
A:（1）内核定时器； （2）用户地址空间； （3）IPC信号；  （4）文件描述符；（5）文件系统数据； （6）进程命名空间；（7）信号处理函数.
Q:进程清理完资源后：
A:经过这一轮清理后, 进程进入僵死状态, 它还占有的资源就是内核栈, thread_info, task_struct, 其目的是向其父进程提供信息。
Q:进程调度
A:时间片 + 优先级。2.5 版本以后, linux 使用了 O(1) 调度程序。
Q:linux使用的两种优先级（1）
A:普通优先级：nice值. -20到19, 默认值为0. 值越大优先级越低--即为其它进程做好事. nice 值还可以决定分配的时间片的大小, -20 最长 19 最短。
Q:linux使用的两种优先级（2）
A:实时优先级. 0 到 99. 任何实时进程的优先级都高于普通进程。
Q:时间片
A:linux 使用动态方式计算时间片, 带来很多好处。默认的时间片为20毫秒。
Q:时间片耗尽
A:当一个进程的时间片耗尽时, 就认为进程到期了。只有在所有进程都耗尽了它们的时间片, 才会重新计算时间片.
Q:linux 为抢占式的. 发生抢占的时机（1）
A:当一个进程进入 task_running 状态, 内核会检查它的优先级是否高于当前正在执行的进程, 如果是, 则调度程序会被唤醒, 抢占.
Q:linux 为抢占式的. 发生抢占的时机（2）
A:正在执行的进程的时间片变成0时。系统返回用户空间时。系统从中断返回时。
Q:linux 为抢占式的. 发生抢占的时机（3）
A:这个说法还有些问题, 其实, 当前两个发生时, 当前进程的进程描述符的 need_resched 标志会被置为1. 然后, 在后两件事发生时, 如果该值为1 , 则调用 schedule() 进行进程调度.
Q:内核抢占（1）
A:上面说的是用户抢占. 内核抢占是linux的一个较新的功能. 在没有内核抢占的os上, 内核代码会一直执行到完成(返回用户空间) , 或明显的阻塞时。在某些情况下，会导致低效。
Q:内核抢占（2）
A:系统运行在内核态时，也可以发生抢占。前提是当前代码没有持有锁。因为如果持有锁, 则抢占是不安全的.
Q:内核抢占（3）
A:内核抢占发生的时机是: 从中断返回内核空间时。
Q:非抢占下的进程调度时机
A:（1）进程退出； （2）进程等待事件, 自我阻塞； （3）进程收到stop信号； （4）进程代码显式的调用 schedule()函数。
Q:进程进入task_running 状态的时机
A:（1）进程被创建；（2）等待的事件发生； （3）收到信号。
Q:两种资源消耗类型的进程（1）
A:IO消耗性, 大部分时间都在等待用户交互. 比如文字编辑. 此类程序应该有更高的优先级和更长的时间片, 已保证对用户交互的及时响应。
Q::两种资源消耗类型的进程（2）
A:CPU消耗性. 大部分时间都在进行cpu处理. 比如视频编解码程序。
Q:如何判断一个进程交互性强不强（1）
A:标准时进程休眠的时间长短. 如果一个进程大部分时间都在休眠, 那么它就是IO消耗性. 如果一个进程执行的时间比休眠的时间长, 那么它就是CPU消耗性.
Q:如何判断一个进程交互性强不强（2）
A:这种推断机制准确得惊人, 而且反应极快, 当一个进程由IO消耗性转变为CPU消耗型, 调度程序会很快做出反应.
Q:如何判断一个进程交互性强不强（3）
A:一个进程的nice即它的静态优先级.
Q:如何判断一个进程交互性强不强（4）
A:进程调度使用的动态优先级, 动态优先级=静态优先级+偏移量. 举例来讲, 如果一个进程是交互性强的, 那么偏移量可能是-5(这是个巨大的奖励)。反之, 如果是CPU消耗性的 ,则偏移量可能是+2.
Q:运行队列
A:运行队列是给定处理器上的可执行进程的链表, 每个处理1个。
Q:优先级数组（1）
A:每个运行队列都有两个优先级数组, 一个活跃的和一个过期的。
Q:优先级数组（2）
A:优先级数组中, 有5个长整数组成优先级位图, 每个位代表一个优先级, 共计160位 (默认优先级有140个), 如果某位置1 , 则表示有该优先级的进程进入就绪态.
Q:优先级数组（3）
A:这样, 要查找当前优先级最高的就绪进程, 就特别简单。实际上,由于linux对每种体系结构都做了优化, 因此这个操作只需要2个时钟. 相关代码参见 sched_find_first_bit().
Q:优先级数组（4）
A:每个优先级都有自己的就绪进程链表. 同一优先级的进程采用轮转方式调度. 当然, 这很公平.
Q:优先级数组（5）
A:调度时, 从优先级位图中找到当前有就绪进程的最高优先级, 然后去对应队列中取第一个进程, 即可. 这就是所谓的 O(1) 调度程序。
Q:重新计算时间片（1）
A:过期的优先级数组就是用来重新计算时间片的. 所有耗尽时间片的进程都放在这个数组中. 在移到过期数组时, 重新计算时间片。
Q:重新计算时间片（2）
A:所以, 等所有进程都耗尽时间片时, 只需要将活跃和过期的数组切换即可。这个切换是O(1) 调度程序的核心.（完美设计）。
Q:静态优先级的确定方法（1）
A:初始创建的进程,nice=父进程的值,时间片=父进程的一半(和父进程评分)。
Q:静态优先级的确定方法（2）
A:优先级最低的进程, nice=19, 时间片=5毫秒；默认优先级的进程, nice = 0, 时间片=100毫秒；优先级最高的进程, nice = -20,  时间片=800毫秒。
Q:睡眠
A:进程休眠有各种原因, 但肯定是为了等待一些事件. 常见的比如文件IO. 休眠进程放在等待队列中. 等待队列即 wake_queue_head_t.
Q:唤醒（1）
A:当于等待队列相关的事件发生时, 队列上的进程被唤醒. 唤醒操作由 wake_up(), 它会唤醒指定的等待队列中的所有进程.
Q:唤醒（2）
A:通常哪段代码促进等待条件达成, 则负责调用wake_up(). 比如,当磁盘数据到来后, VFS就负责对等待队列调用,以便唤醒等待队列中等待这些数据的进程.
Q:伪唤醒
A:有时候进程被唤醒并不是因为它所等待的条件达成了, 比如收到信号时会被唤醒处理。
Q:多处理器系统下的锁处理
A:多CPU系统下, 每个CPU都有自己的可执行队列和锁. 但假如各CPU苦乐不均, 那么就需要负载平衡程序来解决.
Q:负载平衡程序（1）
A:负载平衡程序在 kernel/sched.c 中的load_balance() 实现. 它有两种调用方式: 在 schedule() 执行时, 如果当前可执行队列为空, 它会被调用.
Q:负载平衡程序（2）
A:另外，它还被定时器调用. 在系统空闲时每隔1毫秒调用一次, 其它情况下每200毫秒调用一次。当然, 单CPU系统, 它不会被调用. 甚至不会被编译到内核。
Q:负载平衡程序的策略（1）
A:1.找最繁忙的可执行队列。 2.先找过期数组, 如果为空, 则找活动数据. 这个很明显,过期数组中的进程已经有很长时间没有得到执行了.
Q:负载平衡程序的策略（2）
A:3.找优先级最高的进程链表。然后，选择其中不是正在执行, 也不会因为cpu相关性而不可移动, 且不在高速缓存的进程, 然后调用 pull_task() 将其抽取为当前进程.
Q:实时调度（1）
A:linux 提供了两种实时调度策略: sched_fifo 和 sched_rr.
Q:实时调度（2）
A:前者非时间片, 即这种优先级的进程会一直执行下去, 直到它被阻塞或主动释放cpu. 但是可以被更高优先级的进程抢占.
Q:实时调度（3）
A:后者即带时间片的sched_fifo.
Q:实时调度（4）
A:linux 的实时调度算法提供了一种软实时工作方式, 它不能保证总能满足实时进程的需求。但尽管如此, 2.6 的核心可以满足非常严格的实时要求.
Q:系统调用（1）
A:系统调用时用户空间访问内核的唯一手段。除异常和陷入外, 它是内核唯一的合法入口。
Q:系统调用（2）
A:linux 的系统调用是作为c库的一部分提供的. 系统调用在内核中实现, 运行于内核空间。应用程序不需要关注系统调用.
Q:API和系统调用的区别
A:API是由OS提供的、供应用程序使用的编程接口. 它的实现可以是一个系统调用, 也可以是多个系统调用, 亦可和系统调用无关.
Q:POSIX标准
A:linux 最流行的API 是基于POSIX标准的。标准是IEEE负责发布的, 目的是为了基于unix 的可移植操作系统的标准. linux与之兼容. 象windows , 尽管和unix无关, 也提供了和POSIX兼容的库.
Q:机制和策略（1）
A:关于unix的界面设计有一句格言: "提供机制而不是策略". 换句话说, unix的系统调用抽象出用于完成某种确定目的的函数; 至于这些函数怎么使用完全不需要内核去关心.
Q:机制和策略（2）
A:区分机制(mechanism)和策略（policy）是Unix设计中的一大亮点。
Q:机制和策略（3）
A:大部分的编程问题都可以被切割成两个部分：“需要提供什么功能”（机制）和“怎样实现这些功能”（策略）。如果由程序中的独立部分分别负责机制和策略的实现，那么开发软件就更容易，也更容易适应不同的需求。
Q:Linux抽象出对这些对象的执行机制（1）
A:程序的执行机制--进程；内核函数的执行机制--线程；中断服务程序的执行机制--中断信号触发；
Q:Linux抽象出对这些对象的执行机制（2）
A:中断下半部的执行机制--softirq，tasklet，工作队列；系统调用的执行--软中断（int $0x80触发）。
Q:系统调用在内核中实现（1）
A:例子如下:asmlinkage long sys_getpid(void){ return current->tgid; }
Q:系统调用在内核中实现（2）
A:请注意它有两个特点: 函数声明中有asmlinkage, 所有系统调用都需要这个限定词.
Q:系统调用在内核中实现（3）
A:至于系统调用 get_pid() 在内核中被定义为 sys_getpid(). 这个是linux系统调用都遵守的命名规则, 即加入 sys_ 前缀.
Q:系统调用号
A:每个系统调用都被赋予一个系统调用号. 一旦被分配, 就不能有任何变更. 该列表存储在 sys_call_table 中.
Q:应用程序如何通知内核自己需要执行一个系统调用？
A:软中断. 通过引发一个异常来促使系统切换到内核态去执行异常处理程序.  x86系统上的软中断是通过 int $0x80指令产生. 这条指令会触发一个异常导致系统切换到内核态并执行第128号异常处理程序, 而该程序就是系统调用处理程序, 即 system_call().
Q:系统陷入内核空间还不够, 系统调用号是如何传入的呢?
A:x86上是通过eax寄存器传递的.
Q:系统调用还有参数, 要如何传递?
A:寄存器. x86 上, ebx, ecx, edx, esi 和 edi 可以放前5个参数. 如果有6个或以上的参数(不多见), 则有一个寄存器存放指向所有参数的用户空间的指针.
Q:返回值放在哪里？
A:返回值也是放在寄存器的. x86上是eax.
Q:整个流程如下:
A:用户程序调用 read() -> c库封装的代码 -> system_call() -> sys_read().
Q:系统调用的实现理念（1）
A:确定它的用途. 每个系统调用都应该有明确的用途. linux 不提倡采用多用途的系统调用. ioctl() 即是个反例.
Q:系统调用的实现理念（2）
A:参数, 返回值和错误码要力求简洁. 参数尽可能少.
Q:系统调用的实现理念（3）
A:系统调用的语义和行为要力求稳定.
Q:系统调用的实现理念（4）
A:别对别人会怎么用它做过多的假设. 比如不要对字节长度和字节序做假设. 否则影响可移植性和健壮性.(基本的unix调用的很大部分到现在还和30年前一样适用和有效).
Q:系统调用的参数检验（1）
A:最重要的检查是检查用户传入的指针是否有效. 内核在使用用户传入的指针前, 必须保证：
Q:系统调用的参数检验（2）
A:1.它是属于用户空间的;2. 它在该进程的地址空间内的 , 也就是说不能属于其它进程.3. 访问必须有对应的权限.
Q:向用户空间写入数据的做法
A:内核提供了copy_to_user(), 它需要三个参数: 进程空间的目标内存地址, 内核空间的源地址, 需要拷贝的字节数.
Q:从用户空间读取数据的做法
A:内核提供了 copy_from_user()。如果执行失败, 两个函数返回的都是没能完成拷贝的数据的字节数. 如果成功, 返回0.
Q:权限检查
A:针对调用者是否有合法权限. 采用 capable() 函数来检查. 比如, capable(CAP_SYS_NICE) 可检查调用者是否有权改变其它进程的nice值。相关权限列表 参见 linux/capability.h。
Q:系统调用上下文
A:内核在执行系统调用时, 处在进程上下文。在进程上下文中, 内核可以休眠和被抢占。
Q:休眠的能力非常重要
A:说明系统调用可以使用内核提供的绝大部分功能. (与之对应的是, 由于中断上下文不具休眠能力, 导致其能进行的操作相当受限).
Q:被抢占的特点
A:被抢占的特点要求，系统调用的实现必须是可重入的。
Q:如何定义一个新的系统调用？
A:过程有点繁琐, 所以尽管很有趣,此处不累述.有兴趣者见5.5.1 章节.
Q:不要创建新的系统调用
A:至少是不要轻易创建 (新增系统调用已经不再被支持了)。
Q:创建一个系统调用的好处
A:系统调用创建容易而且使用方便；linux 系统调用的高性能。
Q:创建一个系统调用的问题
A:需要一个系统调用号, 而且要由官方分配给你；系统调用加入稳定版本后就被固化了；需要把系统调用分别注册到需要支持的各种体系结构中；在脚本中不容易调用系统调用, 也不能从文件系统中调用。
Q:替代办法（1）
A:创建一个设备节点, 通过 open() close() , read() 和 write()访问它. 用  ioctl() 进行特别的设置操作和获取特别的信息.( rmt_oeminfo 就是一个设备节点 ).
Q:替代办法（2）
A:一些接口如信号量，可以用文件描述符进行操作。把增加的信息放在sysfs的合适位置。
Q:中断（1）
A:中断使得硬件得以和处理器进行通讯。它本质上是一种特殊的电信号, 由外设发给处理器.。
Q:中断（2）
A:处理器一经检测到此信号, 便中断自己的当前工作转而处理中断。中断随时会发生。
Q:中断请求线(IRQ)
A:不同的设备对应的中断不同, 而每个中断都通过一个唯一的数字标示来区分. 这些中断值被称为IRQ. 比如x86上, IRQ0 是时钟中断, IRQ1 是键盘中断. PCI 总线上的设备的中断是动态分配的.
Q:异常
A:异常由 CPU 产生(换句话说, 是软件产生), 大部分由于当前运行代码出现问题导致, 比如除零异常, 缺页异常, 以及系统调用异常.
Q:异常和中断
A:异常和中断的处理非常类似. 而且又因为要考虑与处理器时钟同步（？）, 所以, 异常常被称为同步中断.
Q:中断处理程序(ISR)
A:ISR 是被内核调用来响应中断的. 它运行在中断上下文中。除此之外, ISR 就是普通的c函数。
Q:上半部和下半部（1）
A:中断无疑是要快速处理的, 因为首先硬件可能有严格的时序限制, 其次系统的其它被打断的部分需要尽快回去恢复。
Q:上半部和下半部（2）
A:但是很多中断需要处理的工作量很大, 比如网卡.因此我们一般把中断处理切分为两部分. 上半部只完成由严格时限的部分.
Q:注册中断处理程序
A:中断处理程序时管理硬件的驱动程序的组成部分。如果设备使用中断 (大部分设备都如此), 那么相应的驱动程序就注册一个中断处理程序。
Q:注册isr用request_irq()，其参数表（1）
A:第一个参数表示要分配的中断号. 对于传统设备, 比如部分时钟和键盘, 这个值是定死的. 而对于大多数其它设备, 这个值要么是通过探测获取, 或者在编程动态确定.
Q:注册isr用request_irq()，其参数表（2）
A:第二个参数即中断处理程序的指针. 其原型是确定的.
Q:注册isr用request_irq()，其参数表（3）
A:第三个参数 irqflags 可以为0, 也可以为如下值:
Q:注册isr用request_irq()，其参数表（4）
A:SA_INTERRUPT: 表示为快中断. 加此标志的中断会在禁止所有中断的情况下运行. 这使得FIQ 的处理不被打扰. 一般IRQ则只屏蔽自己这条中断线, 而其它中断都是激活的.
Q:注册isr用request_irq()，其参数表（5）
A:SA_SAMPLE_RANDOM: 表示当前isr 的中断间隔时间作为熵源填充到内核的熵池中. 熵池是为了产生真随机数.
Q:注册isr用request_irq()，其参数表（6）
A:SA_SHIRQ: 表示当前isr 和 其它isr共享同一个中断线. 同一中断线上注册的每个处理程序都必须指定这个标志.
Q:注册isr用request_irq()，其参数表（7）
A:第四个参数 devname 是入中断有关的设备的名字的ascii 码字符串. 这个名字会被 /proc/irq 和 /proc/interrupt 使用.
Q:注册isr用request_irq()，其参数表（8）
A:第五个参数 dev_id 主要用于共享中断线. 当一个中断处理程序需要释放时, 此参数将提供唯一的标示信息, 以便从共享中断线的诸多中断处理函数中删除指定的一个.
Q:注册isr用request_irq()，其参数表（9）
A:返回值. 0 表示成功. 非0 表示失败. 最常见的错误是 -EBUSY, 表示给定的中断线已经在使用, 或者没有共享中断线没有加 SA_SHIRQ。
Q:注意: request_irq() 可能会睡眠
A:不能在中断上下文或其它不允许阻塞的代码中调用。只能在进程上下文调用此函数。
Q:request_irq()为什么会睡眠？
A:在注册过程中,内核需要在/proc/irq中增加一个项, proc_mkdir()即是干这个的,proc_mkdir()通过 proc_create()对这个新的profs项进行设置。而后者会调用kmalloc()请求内存。而后者可以睡眠。
Q:释放isr:free_irq()
A:对于非共享中断线, 释放中断处理程序将导致该中断线禁用。必须在进程上下文调用此函数。
Q:编写isr
A:isr 是无需考虑重入的. 因为当一个给定的isr 在执行时, 相应的中断线在所有的cpu上都会被屏蔽掉.
Q:共享中断线
A:内核收到一个中断后, 它将依次调用在该中断线上注册的每一个isr.所以,isr必须有办法得知它的设备是否真的产生了中断. 这既需要硬件支持, 也需要isr中有相应的处理逻辑. 如果isr发现与之相关的硬件并没有产生硬件, 则它应该立即退出.
Q:中断上下文和进程上下文
A:这两个概念都只和内核空间有关系. 表明内核运行的状态。
Q:进程上下文
A:进程上下文是一种内核所处的操作模式, 此时内核代表进程执行--例如执行系统调用或运行内核线程.
Q:在进程上下文下, 可以做如下事:
A:(1)可以通过current宏关联当前进程. (2)可以睡眠. (3)可以调用调度程序.
Q:中断上下文
A:和进程没有什么关系. 所以current 宏指向的是被中断的进程. 不可以睡眠. 因为没有进程的背景, 如何睡眠? 阻塞后如何重新调度? 因此, 不可以在中断上下文中调用那些会导致睡眠的函数.
Q:中断上下文的其它制约（1）
A:具有严格的时间限制. 必须尽可能的迅速简洁. 应该尽量把工作从isr中分离出来, 放在下半部来执行.
Q:中断上下文的其它制约（2）
A:具有严格的空间限制. 2.6版本之前, isr 没有自己的栈, 相反它们共享被中断进程的内核栈. 内核栈的大小为两页, 具体说, 32位系统为8KB, 62位系统为16K.
Q:中断上下文的其它制约（3）
A:2.6版本后, 提供了一个选项, 把内核栈的大小减为1页. 这减轻了内存的压力, 因为系统中每个进程原来都需要8K不可换出的内核内存. 为了应对栈的减少, isr有了自己的栈, 每个cpu一个, 大小为4K. 这个栈称为中断栈.
Q:中断从硬件到内核的路由（1）
A:硬件设备: 产生一个中断(电信号)；中断控制器将其传给给CPU。
Q:中断从硬件到内核的路由（2）
A:CPU: 如果该中断不被禁止, CPU会中断当前工作, 关闭中断系统, 然后跳到内存中预定义的位置(即中断处理程序的入口点)开始执行. 注意, 每条中断线都对应一个唯一的位置. 所以, 内核就知道所接受的IRQ号了.
Q:中断从硬件到内核的路由（3）
A:do_IRQ():计算中断号,确认该号上是否注册有isr.如果没有, 则跳到ret_from_intr()执行。
Q:中断从硬件到内核的路由（4）
A:handle_IRQ_evnet(): 主要做如下事：禁止本中断线, 或者禁止所有中断线(依赖于中断线属性是否有SA_INTERRUPT)；运行该线注册的所有isr.
Q:中断从硬件到内核的路由（5）
A:如果注册期间指定了SA_SAMPLE_RANDOM属性, 则调用 add_interrupt_randomness().
Q:中断从硬件到内核的路由（6）
A:isr调用完后，调用ret_from_intr(): 检查是否有必要进行经常调度. 细节如下：
Q:中断从硬件到内核的路由（7）
A:重新调度是否正在挂起(即设置了 need_resched), 而且内核正在访问用户空间(即中断了用户进程), 则调用 schedule().
Q:中断从硬件到内核的路由（8）
A:如果内核正在返回内核空间(即中断了内核), 只有在 preempt_count 为0 时, schedule() 才会被调用(否则, 抢占内核便是不安全的).
Q:proc fs
A:是一个虚拟文件系统, 它只存在于内核内存, 一般安装于/proc 目录下. 在proc中读写文件都要调用内核函数, 这些函数模仿从真实文件中读和写.
Q:/proc/interrupts（1）
A:/proc/interrupts存放和中断相关的统计信息。cat 它，可以查看如下数据：LOC:    8603870    5633075   Local timer interrupts
Q:/proc/interrupts（2）
A:其中, 第一列为中断线, 这里不显示没有注册处理程序的中断线.
Q:/proc/interrupts（3）
A:第二列为接受到的中断数目的计数器. 我们可以看到,时钟中断已经发生了 8603870次,能算出开机了多长时间吗?
Q:/proc/interrupts（4）
A:第三列式处理这个中断的中断控制器. 在具有IO APIC的系统上, 多数中断都会用IO-APIC-edge.
Q:/proc/interrupts（5）
A:最后一列是与这个中断相关的设备名称. 这个名称是通过 devname 提供给函数  request_irq()的. 如果中断线是共享的, 比如中断16, 则所有设备都会列出.
Q:/proc/interrupts（6）
A:procfs 代码位于 fs/proc, 提供/proc/interrupts 的函数叫做 show_interruptes()。
Q:中断控制, 禁止和激活中断（1）
A:所谓中断控制, 即禁止当前处理器的中断系统, 或者屏蔽掉整个机器的一条中断线.
Q:中断控制, 禁止和激活中断（2）
A:中断控制的目的是需要提供同步. 通过禁止中断, 可以确保某个 isr 不会抢占当前代码. 此外, 禁止中断, 还可以禁止内核抢占.
Q:中断控制, 禁止和激活中断（3）
A:但是, 中断控制不能够防止来自其它CPU的并发访问. 而锁可以. 这是两个层面的事. 即锁防止其它CPU的并发访问, 而禁止中断防止来自其它isr的并发访问.
Q:中断控制, 禁止和激活中断（4）
A:禁止当前CPU上的本地中断: local_irq_disable();
Q:中断控制, 禁止和激活中断（5）
A:激活它们: local_irq_enable();
Q:中断控制, 禁止和激活中断（6）
A:禁止中断并保存状态: local_irq_save(flags);    // flags 为uint32.
Q:中断控制, 禁止和激活中断（7）
A:恢复中断状态: local_irq_restore(flags);
Q:中断控制, 禁止和激活中断（8）
A:显然, 后两者更安全. 因为local_irq_enable() 会无条件激活所有中断, 如果某个中断可能在开始之前就关闭了.
Q:中断控制, 禁止和激活中断（9）
A:后两者必须在同一个函数中调用.
Q:中断控制, 禁止和激活中断（10）
A:所有这四个函数既可以在中断中调用, 也可以在进程上下文中调用.
Q:中断控制, 禁止和激活中断（11）
A:以前内核提供了一种禁止所有CPU上的中断的方法. 后来取消. 原因是需要推动使用更细粒度的锁, 以加快系统速度.
Q:禁止指定中断线（1）
A:此即所谓的屏蔽掉一条中断线.
Q:禁止指定中断线（2）
A:disable_irq(uint irq): 禁止中断线, 函数只有在当前正在执行的所有isr都完成后, 才能返回. 所以调用者要确保不再指定线上传递新的中断, 同时要确保已经开始执行的isr已经全部退出.
Q:禁止指定中断线（3）
A:disable_irq_nosync(uint irq): 禁止中断线, 异步调用. 没有上面函数的限制.
Q:禁止指定中断线（4）
A:enable_irq(uint irq): 激活中断线.
Q:禁止指定中断线（5）
A:syncchronize_irq(uint irq):  等待特定的isr的退出.
Q:禁止指定中断线（6）
A:注意: disable 和 enable 函数必须成对调用, 但可以嵌套.
Q:禁止指定中断线（7）
A:禁止多个isr共享的中断线是不合适的. 而根据规范, PCI设备必须支持中断线共享, 所以新设备极少使用这些接口.
Q:获取中断状态（1）
A:in_interrupt(): 如果内核存在中断上下文, 返回非0.
Q:获取中断状态（2）
A:in_irq(): 内核在执行isr 时, 返回非0.

// 下半部
Q:下半部
A:中断处理流程分为两个部分, 即 isr+下半部(bottom half).
Q:到底什么任务要放在哪个部分完成？
A:对这一点并没有明确的规范, 如何做取决于开发者自己的判断。理想状态下, 最好 isr 将所有工作都交给下半部执行. 因为isr越快越好.
Q:基本的规则如下（1）
A:如果一个任务对时间非常敏感, 比如将数据从硬件读入内存; 那么就放在isr; 
Q:基本的规则如下（2）
A:如果一个任务和硬件相关, 比如操作硬件对中断的到达进行确认, 那么就放在isr;
Q:基本的规则如下（3）
A:如果一个任务要保证不被其它中断(特别是同一中断线的中断)打断, 将其放在isr 中执行;
Q:基本的规则如下（4）
A:其它任务, 考虑放在下半部执行. 换句话说, 凡是没有理由必须放在isr 的任务, 都应该放在下半部.
Q:下半部的执行时间（1）
A:下半部的关键不在和isr隔了一段时间执行, 相反, 多数情况下, 下半部会在isr返回后马上执行.
Q:下半部的执行时间（2）
A:下半部的关键在于当它们运行时, 允许响应所有的中断.锁中断的时间长短, 对系统的性能影响极大.
Q:下半部有多种实现机制（1）
A:最早的叫BH(即bottom half 的缩写), 2.5 内核去掉. 被软中断(softirq)、tasklet 取代。
Q:下半部有多种实现机制（2）
A:后来的任务队列, task queue, 2.5 内核去掉. 被工作队列取代.
Q:下半部有多种实现机制（3）
A:目前在用的机制有: 软中断(softirq), tasklet, 工作队列(work queue).  其中 tasklet 通过软中断实现. 而工作队列则和它们完全不同.
Q:下半部有多种实现机制（4）
A:软中断(softirq), tasklet 运行在中断上下文; 工作队列运行在进程上下文.
Q:软中断（1）
A:软中断使用较少, 一般用于象网络这种对性能要求高的情况下. 而且, 内核代码中明确要求不要再分配新的软中断.
Q:软中断（2）
A:代码位于 /kernel/softirq.c
Q:软中断（3）
A:软中断需要在编译期间静态分配.
Q:软中断（4）
A:软中断有 softirq_action 结构表示。struct softirq_action{void (*action)(struct softirq_action *);};
Q:软中断（5）
A:softirq.c 定义了 NR_SOFTIRQS个该结构体的数组.后者为软中断的枚举量,每个被注册的软中断都占据该数组的一项.目前该值为 10. 即最多可能有10个软中断.
Q:执行软中断的时机（1）
A:从一个 isr 返回时;
Q:执行软中断的时机（2）
A:在 ksoftirqd 内核线程中; (7.12 会讲)
Q:执行软中断的时机（3）
A:在那些显式执行待处理的软中断的代码, 比如网络子系统就是自行重复触发的.
Q:执行软中断的时机（4）
A:不管哪种方式, 软中断都在 do_softirq() 中. do_softirq() 会遍历寻找所有待处理的软中断, 并根据其优先级依次调用其处理函数.
Q:执行软中断的时机（5）
A:目前, 只有网络和SCSI 两个子系统直接使用软中断. 此外, 内核定时器和tasklet都是建立在软中断上的.
Q:软中断的类型（1）
A:也是其优先级, 排在前面的优先级高。HI_SOFTIRQ（高优先级的tasklet） > TIMER_SOFTIRQ（内核定时器） > NET_TX_SOFTIRQ（发送网络数据包）> NET_RX_SOFTIRQ（接收网络数据包）
Q:软中断的类型（2）
A:BLOCK_SOFTIRQ（块设备？）> BLOCK_IOPOLL_SOFTIRQ（块设备io池？）> TASKLET_SOFTIRQ（tasklet）> SCHED_SOFTIRQ > HRTIMER_SOFTIRQ > RCU_SOFTIRQ > NR_SOFTIRQS（软中断）

使用软中断

   * 分配索引, 即7.7描述的. 注意, 由于其次序决定优先级, 所以不一定总是添加到列表的末尾.
   * 注册处理函数. 调用 open_softirq()
open_softirq(TASKLET_SOFTIRQ, tasklet_action);
open_softirq(HI_SOFTIRQ, tasklet_hi_action);
软中断处理程序执行时, 允许响应中断, 当前CPU的软中断被禁止, 但是其他CPU 仍可以执行别的软中断, 甚至是自身. 所以 ,软中断中使用全局变量会很麻烦 , 如果加锁来防止自身的并发执行, 那么软中断就没有任何使用的必要了.
   * 触发你的软中断
raise_softirq_irqoff(TASKLET_SOFTIRQ);
或者
raise_softirq(NET_TX_SOFTIRQ);
   * 触发的时机
在isr中触发软中断是最常见的形式. 在这种情况下, isr 执行硬件设备的相关操作, 然后触发相应的软中断, 最后退出. 内核执行完 isr 后, 马上就会调 do_softirq().


// 进程间通讯
Q:管道（pipe）
A:可用于有亲缘关系的进程间的通讯。/Users/duangan
Q:有名管道（named pipe）
A:除有管道的一切功能外，还允许无亲缘关系的进程间的通讯（因为有名字）。
Q:信号（signal）
A:信号实现较复杂。用于通知进程有某事发生。接口为sigal和sigaction，两者兼容。
Q:消息队列（message）
A:信号能承载的信息少，管道只能承载无符号字节流，为克服这两种不足，设计了消息队列，可以存放多个且格式化的信息。
Q:共享内存
A:使得多个进程可以访问同一个内存空间，是最快的IPC实现方式。
Q:信号量（semaphore）
A:主要作为进程间同步手段。
Q:socket
A:更为一般的IPC方式。


