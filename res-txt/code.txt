// 代码 设计 模式 重构
// V0.9

Q:了解你的计算机（x86，单位为1kik）
A:执行一条指令：1； 从L1 cache中获取一个字：2；从内存中读一个字：10；从磁盘连续位置取一个字：200；从磁盘任意位置取一个字：（8000000）。
Q:软件
A:而今，人类文明运行于软件之上。
Q:编程语言的变革是软件生产力的最大推动者
A:编程语言是推动软件技术发展最有力的技术之一。

// 敏捷
Q:2001年敏捷宣言发布。
A:签字的人中有顶级程序员：Kent Beck, Robert C.Mortin, Marin Fowler。
Q:敏捷宣言（1）
A:个体和交互 胜过 过程和工具
Q:敏捷宣言（2）
A:可以工作的软件 胜过 面面俱到的文档
Q:敏捷宣言（3）
A:客户合作 胜过 合同谈判
Q:敏捷宣言（4）
A:响应变化 胜过 遵循计划
Q:敏捷宣言（5）
A:虽然右项也具有价值，但我们认为左项具有更大的价值。
Q:敏捷可解决什么问题？
A:变化。
Q:变化从哪里来？
A:数据（DOD）显示，初期提出的45%的需求无用处。
Q:敏捷与问题
A:敏捷是帮助发现问题的，不是解决问题。敏捷的本质是尽早暴露问题，以便修正。

Q:完整团队
A:XP项目的所有参与者（开发人员、业务分析师、测试人员等等）一起工作在一个开放的场所中，他们是同一个团队的成员。
Q:计划游戏
A:计划是持续的，循序渐进的。每2周，开发人员就为下2周估算候选特性的成本，而客户则根据成本和商务价值来选择要实现的特性。
Q:客户测试
A:作为选择每个所期望的特性的一部分，客户定义出自动验收测试来表明该特性可以工作。
Q:简单设计
A:团队保持设计恰好和当前的系统功能相匹配，它通过了所有的测试，不包含任何重复，表达出了编写者想表达的所有东西，并且包含尽可能少的代码。
Q:结对编程
A:所有的产品软件都是由两个程序员，并排坐在一起在同一台电脑上构建的。
Q:测试驱动开发
A:程序员以非常短的循环周期工作，他们先增加一个失败的测试，然后使之通过。
Q:改进设计
A:随时改进糟糕的代码。保持代码尽可能的干净，具有表达力。
Q:持续集成
A:团队总是使系统完整地被集成。
Q:集体代码所有权
A:任何结对的程序员都可以在任何时候改进任何代码。
Q:编码标准
A:系统中所有的代码看起来就好像是被单独一个--非常值得胜任的--人编写的。
Q:隐喻
A:团队提出一个程序工作原理的公共景像。
Q:可持续的速度
A:团队只有持久才有获胜的希望，他们以能够长期维持的速度努力工作，他们保存精力，他们把项目看作是马拉松长袍，而不是全速短跑。

Q:迭代模型
A:2-3周为一个周期；第一天确定了需求就可以编码；各个阶段并行。
Q:建模的方法
A:workshop，笔、卡片、面对面；设计和实现不可分割。
Q:敏捷经济学
A:争取每时每刻都在做最有价值的事情，低价值的事情要往后放、往下砍。小步快跑，每一步都做价值判断，减少风险成本。
Q:敏捷与文档
A:文档就是代码及测试。
Q:敏捷运作之3C
A:card、confirmation、communication。
Q:敏捷的关键
A:不实施TDD，持续集成就没有效果，进而破坏迭代，导致敏捷化为乌有。
Q:敏捷转型
A:关注价值，测试驱动，小步快跑，团队协作，因势利导，实事求是。
Q:转型的关键因素
A:（1）清晰的愿景；（2）不断演进；（3）多层次的承诺和参与；（4）识别障碍和困难；（5）选择何时的敏捷实践；（6）坚持。
Q:时间和交付工作集
A:按工作集来确定发布时间，而不是按时间来确认工作集。
Q:好代码的本质特征
A:是软件中没有重复功能的代码（保证正交性）。一个优秀的系统，找不出多余的东西。
Q:敏捷的局限（一家之言）
A:敏捷解决的仅仅是稳定架构下的开发问题。
Q:敏捷方法学
A:务实。一切都围绕快速、高质量的交付软件。什么东西在妨碍目标达成，就“无情”的去掉。
Q:痛切之语（1）
A:软件生命周期概念是有害的。
Q:痛切之语（2）
A:当年发明高级语言就是想让编程能轻松一点，但事实上，有了高级语言后，编程变得越来越复杂。
Q:痛切之语（3）
A:很多人一直拿着项目管理模式来做软件产品的系统工程模型。项目管理侵入了软件产品系统工程中。
Q:软件系统的内在规律（1）
A:复杂性几乎无法归约。系统不可能一蹴而就，人类在复杂系统前只能渐进迭代思考；
Q:软件系统的内在规律（2）
A:软件缺陷有极大的相关性，如果不及时清理，就会指数级上升。
Q:系统工程与项目管理的区别（1）
A:前者：设计质量决定系统质量；后者：软件生命周期
Q:系统工程与项目管理的区别（2）
A:前者：信息隐藏；后者：清晰的需求管理
Q:系统工程与项目管理的区别（3）
A:前者：持续集成；后者：测试策略；
Q:系统工程与项目管理的区别（4）
A:前者：重视复杂度；后者：重视组织成熟度
Q:系统工程与项目管理的区别（5）
A:前者：成功取决于是否有精于技术的领导；后者：是否有完美的管理流程。
Q:系统工程与项目管理的区别（6）
A:前者：团队每阶段的自反馈；后者：项目时间点控制
Q:系统工程与项目管理的区别（7）
A:前者：设计与实现不分离；后者：成本、设计和视野决定成功。
Q:传统软件管理方式的一个大问题
A:对软件工作量的估计是海森堡测不准。从这个意义上，敏捷是最务实的。
Q:如果收集、分析客户需求？（1）
A:组织一个workshop，让客户放松，并和大家建立信任关系，比如大家通报自己的情况，有利于相互信任。分析需求的方法：用卡片形式。
Q:如果收集、分析客户需求？（2）
A:用卡片形式和客户一起分析需求。首先和客户坐在一起，由分析人员与客户问答的形式理解业务流程的规范。
Q:如果收集、分析客户需求？（3）
A:其次用三种颜色的卡片来记录业务流程。红色写业务流程的角色，即用的人；浅蓝色记录高层业务流程；白色记录该活动的细节流程。业务流程从左到右、从上到下。
Q:如果收集、分析客户需求？（4）
A:这种方式的优势：直观、深入、高效。

// 基于敏捷的软件设计
Q:SRP 单一职责原则
A:就一个类而言，应该仅有一个引起它变化的原因。
Q:OCP 开发-封闭原则
A:软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改。
Q:LSP Liskov替换原则
A:子类型必须能够替换掉它们的基类型。
Q:DIP 依赖倒置原则
A:抽象不应该依赖于细节。细节应该依赖于抽象。
Q:ISP 接口隔离原则
A:不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。
Q:REP 重用发布等价原则
A:重用的粒度就是发布的粒度
Q:CCP 共用封闭原则
A:包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。
Q:CRP 共同重用原则
A:一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中所有类。
Q:ADP 无环依赖原则
A:在包的依赖关系图中不允许存在环。
Q:SDP 稳定依赖原则
A:朝着稳定的方向进行依赖。
Q:SAP 稳定抽象原则
A:包的抽象程度应该和其稳定程度一致。

// 重构
Q:重构的原则1（个人看法）
A:只在已验证ok的代码上进行重构。
Q:重构的原则2
A:保持小步快跑的原则，每次优化一点，优化完毕后及时验证。验证ok后形成新的基线。周期不要超过1-2周。
Q:重构的原则3
A:任何时刻都要保持一个验证ok的版本。
Q:维护成本很大
A:维护成本至少是开发成本的2倍。
Q:个人编码习惯
A:编码前，要在纸上进行设计，其中复杂逻辑，要有流程草图；测试计划也要在纸上画一画。
Q:个人编码习惯
A:每句话都要有根据。

// 代码的坏味道
Q:代码的坏味道1
A:重复的代码。重复的代码是万恶之源。
Q:代码的坏味道2
A:过长的函数，超过100行；
Q:代码的坏味道3
A:过长的参数列表，超过7个。
Q:代码的坏味道4
A:发散式的变化，某个模块（或函数）常因不同的原因而变化。
Q:代码的坏味道5
A:散弹式的变化，每次修改一个小的功能，都要在系统多处修改，每处只修改一点。
Q:代码的坏味道6
A:依恋情节，某个模块为了实现某个需求，经常要访问另一个模块的接口。
Q:代码的坏味道7
A:数据泥团，总是绑在一起的数据。比如有数十、上百个字段的结构或数据表。
Q:代码的坏味道8
A:令人迷惑的临时值域，一些意义不明确的临时变量。
Q:代码的坏味道9
A:过度耦合的信息链，多个模块间的多对多的信息耦合。
Q:代码的坏味道10
A:中间人模块，一个模块的大部分接口都是委托给他人，这种模块本不必要存在。
Q:代码的坏味道11
A:狎昵关系，两个类经常要访问彼此的私有数据。
Q:代码的坏味道12
A:过多注释。注释是必要的，但是如果由于算法太复杂以至于要写下长长的注释，那么也许更应该简化算法。

// 杜军
Q:编程能力1
A:编程能力一定是为某个业务服务的，因此，程序员要想清楚自己希望朝哪个业务领域发展；
Q:编程能力2
A:凡是依赖倒置的，都是面向对象的；反之则是面向过程的。
Q:编程能力3
A:从编程角度，面向过程即面向编辑器；面向对象，即面向现实世界。
Q:编程能力4
A:敏捷唯一指的是软件团队的应变能力。
Q:编程能力5
A:简单的代码不等于篇幅简短的代码，也不等于拒绝运用技巧。
Q:编程能力6
A:各种度量工具给出的都是工程指标，好的代码至少有一半是无法度量的，只能在需求快速变化中得到检验。

// 不要自称为程序员
Q:不要自称为程序员1
A:90%的编程工作来自内部软件。
Q:不要自称为程序员2
A:别人雇你的目的，是让你制造利润，即增加收入，降低成本。
Q:不要自称为程序员3
A:应该把自己描述为与增加收入、降低成本有关系的人。一个google人的简历这么说：google 97%的收入都和我的代码有关。
Q:程序员求职1
A:不要把自己限定在某种语言，或某种技术上。而是在推销某种产业需求。
Q:程序员求职2
A:平等的对话；要还价，并善于妥协；要事先想好如何回答关于上一份工资是多少的问题。

Q:编程界的下一件大事是什么？1
A:web编程会变成最重要的客户端编程。所以传统的客户端编程方法，比如gtk、java、swt、qt、mfc、cocoa等都不重要了。
Q:编程界的下一件大事是什么?2
A:会有一个更高级的语言，重要的特征事把简单的数据库操作集成到语言中去。vb不是个好语言，但是其数据库结构的便利性，较之大家讨论了十几年的OO对生产率的影响更大。
Q:编程界的下一件大事是什么?3
A:大规模的分布式处理。

Q:怎样衡量程序员的贡献？
A:开源的方法可以一试。开源社区有如下好处：1.灵活的工作传说；2.结果导向；3.署名；4.同行审视。

// C语言相关
Q:字节序
A:X86字节序为低字节在低地址，高字节在高地址，即小头。与人的自觉相反。arm字节序为大头，高字节在低地址，与人的自觉相同。
Q:定义可变参数的宏
A:##_VA_ARGS_ 宏，可以接受可变数目的参数。C99和gcc支持。linux主要用于log打印。

Q:设计通讯协议的关注项（1）
A:字节序。x86和arm正好相反，需要注意。
Q:设计通讯协议的关注项（2）
A:4字节对齐；非常容易出问题。
Q:设计通讯协议的关注项（3）
A:常见错误是字段类型的预期不一致。length字段的宽度要统一，4字节还是2字节；
Q:设计通讯协议的关注项（4）
A:字符串编码，是utf8还是ascii/GBT。
Q:设计通讯协议的关注项（5）
A:字符串是用C字符串，还是Pascal字符串；
Q:设计通讯协议的关注项（6）
A:数组的实现，比如MTP数组在开始有4字节的长度。

// UT用例的设计方案1
Q:规格导出法
A:顾名思义，就是将规格切分为一个个的用例。
Q:等价类法
A:基于对输入、输出集合中的等价子集，每个只找一个作为用例。这个要求判断力较强。
Q:边界值法
A:这个方法是对等价类法的补充。边界最容易出问题。

// COM本质论
Q:COM考虑的主要因素
A:COM充分考虑累人的自然因素和资本因素（资本逐利，核心资产开源许多企业都不认可）。
Q:对面向对象的不同看法
A:面向对象包括三方面：封装、多态、继承。这是学院派的圣杯。COM则认为，识别能够在现实世界落实的因素更重要。三者之中，关键是重用。
Q:COM如何做重用？
A:接口继承比实现继承更好。COM是面向组件的，它通过二进制封装来实现组件重用。重用要解决三个问题：where/who/how。
Q:软件框架要解决的首要问题是什么？
A:为了区别变化和不变的部分提供工具支撑。
Q:COM如何做到这一点？（1）
A:如果只是实现变化，接口不变，则无问题。如A调用B，A和B各自演进，且没有彼此的源代码；只要接口不变，则无问题。
Q:COM如何做到这一点？（2）
A:如果接口变化，需要调用方适配新旧两种接口，保证向下兼容。在A和B中，旧A不可以调用新B，其它组合无问题。
Q:COM如何做到这一点？（3）
A:继续解释，作为A，可以在运行时探测系统中存在哪个版本的B，并决定该用哪种接口，这是COM的强大之处，也是COM设计时要搞定的首要问题。

// 编程成功的方法
Q:编程成功的方法1
A:设法对编程感兴趣，并因为它有趣而编一些程序；
Q:编程成功的方法2
A:与其它程序员交流；阅读其它程序。和他们一起做项目。在其它人之后接手项目，使自己理解别人写的程序。
Q:编程成功的方法3
A:写程序，更多的写程序。学习至少半打编程语言。
Q:编程成功的方法4
A:了解你的计算机。
Q:编程成功的方法5
A:参与一种语言的标准化工作。

// 软件开发的哲学思考
Q:软件开发的哲学思考（1）
A:软件开发的本质是基于人类思考的一种心智活动，它来自人类灵魂的思索。
Q:软件开发的哲学思考（2）
A:计算机有无限的能耐，但要套上开发者为其准备的紧箍咒，因为开发者能力有限。
Q:软件开发的哲学思考（3）
A:程序员为何允许别人控制他的生活？因为他发现自己无法凭空捏造出生活用品。
Q:软件开发的哲学思考（4）
A:软件开发的混乱，是来源于灵活性。如此多的变量，如此多的判断点和如此多的选项。
Q:软件开发的哲学思考（5）
A:软件的主要瓶颈是人。人是任何系统中最不稳定的因素。
Q:软件开发的哲学思考（6）
A:谁也不知道驱动这一切的动力是什么？
Q:软件开发的哲学思考（7）
A:计算机简直就是人类的一面镜子。

Q:优秀程序员具有如下特征（1）
A:希望他们接触过的任何东西都保持良好的状态。
Q:优秀程序员具有如下特征（2）
A:认为编程是一种创造性的过程，并在他们的工作中加入艺术元素。
Q:优秀程序员具有如下特征（3）
A:在开始写代码之前，首先考虑代码的结构。
Q:优秀程序员具有如下特征（4）
A:面对凌乱的代码，会觉得在开始对他们做任何额外工作前，需要先进行一些清理和调整。
Q:优秀程序员具有如下特征（5）
A:坚持不断的学习其它软件的设计，积累成功或失败的经验。

Q:对程序员最重要的事1
A:1.沟通能力。程序员应该参加一些写作培训，以及公开演讲培训；2.品味；3.对有价值的事的感觉。4.专注。
Q:对程序员最主要的事2
A:5.吃早晨；6.把事情想清楚的能力；7.能为自己的自觉提供证据的能力。

// android框架的未来发展趋势
Q:什么是架构？（1）
A:整体性。目的是飞，来自老板或行业需求，架构师就是干可实现计划的。每个零件都不会飞，结构设计好，整体就可以飞。
Q:什么是架构？（2）
A:去分析抽象每个不能飞的零件不是架构师的责任。
Q:什么是架构？（3）
A:设计主要是设计别人。
Q:对未来的想象力
A:从一个想法出发，形成一条切实可行的路。
Q:hal体现了google对产业的理解力
A:linux基金会与硬件厂商的矛盾；hal将linux架空，解决了这个问题，也就释放了产业界的威力。
Q:通用性 VS 独特性
A:通用性不重要，重要的是将很多元素组合起来，形成独特性。
Q:抽象
A:抽象的目的是接口。
Q:电视是手机的大屏 VS 手机是电视的小屏
A:等价于 基于手机的家庭云 VS 基于电视的家庭云。目前还没有答案。
Q:云和端各是解决什么问题的?
A:云：数据在哪里。   端：人机接口在哪里，尤其是显示在哪里。
Q:愿景派 VS 需求派
A:愿景派：先有愿景，推导架构，然后用需求来验证架构；需求主要用来做减法。需求派没有愿景，从需求推导架构。
Q:现有的行业情况
A:内容 - 软件 - 网络-用户 - 硬件。网络占据中心，垄断用户，软件和硬件分得很开。
Q:未来可能的行业情况
A:硬件 - 软件 - 内容 - 网络 - 用户。以硬件为核心，软件和应用围绕硬件，做全面整合；软件发挥硬件的特性；软件、硬件称为内容创新的点。
Q:EIT架构
A:linux驱动框架 - hal层 - binder - java应用框架
Q:架构要保护什么？
A:保护自己的变动自由度，保护第三方的稳定。
Q:跨平台不是随便跨的
A:自己跨别人的平台，自己就主动了。被别人跨平台，就很被动。

// 代码的度量及度量工具
Q:CC：圈复杂度
A:cyclomatic complexity。是一种代码复杂度的衡量标准。计算公式为：V(G)=n+1。其中，n表示判定节点的数量，指if...else 和 switch...case分支的数量。
Q:CC的业界对比情况
A:业界标准<10，无线软件平均是19.82，最大为1274。
Q:Depth：嵌套深度
A:主要指条件及循环嵌套的层次。
Q:Depth的业界对比情况
A:业界标准无此项数据；无线软件平均3.66，最大为17。
Q:Fan-out：扇出数
A:指一个函数直接调用其它函数的数目。这个值越小维护性、代码可读性越好。
Q:Fan-out的业界对比数据
A:业界数据<7，无线软件为27.8，最大为2006。
Q:Avg CC/Depth/Fan-out
A:对这三个指标进行加权，权重为每个函数的语句占比，例如：avg CC=sum(CC*state)/sum(state)，state表示代码行数。
Q:MI
A:MI指可维护性系数，MI=avg CC + avg depths + avg Fan-out。它是相对值。
Q:为什么需要MI这个值？
A:因为CC、depths、Fan-out这三个指标不能互相替代，各有其代表性。从实践上看，随着版本演进，depths和Fan-out有明显的恶化趋势。

// 工具
Q:如何统计重复代码？
A:simian可以统计。
Q:如何统计代码行？
A:
Q:问题单基本命令
A:pn mb me

// 充分挖掘多核性能资源
Q:充分挖掘多核性能资源（1）
A:CPU由单核变成多核，理想情况是代码不改动，软件性能可以线性增长。
Q:充分挖掘多核性能资源（2）
A:多核性能优化涉及的元素包括：OS、编程语言、平台、软件。
Q:充分挖掘多核性能资源（3）
A:主流架构是SMP（对称多核），目标是代码不动，通过编译器优化指令流，达到平滑过渡。
Q:充分挖掘多核性能资源（4）
A:linux具有SMP能力，而c/c++不支持，需要用多线程库来重新实现。
Q:充分挖掘多核性能资源（5）
A:java等基于虚拟机；python、Ruby等动态语言；erlang函数式语言，在SMP方面较之c/c++都有天然的优势。
Q:充分挖掘多核性能资源（6）
A:另一个架构是AMP（非对称多核），即每个核跑一个OS，OS上再跑多个应用。









